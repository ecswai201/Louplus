[TOC]

**作业1**  思考为什么log 是这么打印的？又是如何保存的？请提前找到自动化框架中log模块，阅读相应的代码，将自己的问题记录下来

**作业2** ：创建自己log 类，针对log等级设置不同的颜色，可以制定log的保存路径,可以参考自动化框架中对logging模块的使用和封装（ｍｏｄｕｌｅ＼ａｎｄｒｏｉｄ＼pccolorprt.py）

#  1.添加日志记录

  想要在脚本中添加log 可以使用python 内置模块==logging==

##     1.1给脚本添加日志记录

​				**作业1**  思考为什么log 是这么打印的？又是如何保存的？请提前找到自动化框架中log模块，阅读相应的代码，将自己的问题记录下来

![image-20211212075459749](C:\Users\ying.xue\AppData\Roaming\Typora\typora-user-images\image-20211212075459749.png)

`logging.basicCongfig()`进行一些初始化设置

==filename 参数==让log 信息保存在文件里，不会输出到控制台
==level参数==是一个过滤器，等级低于此的消息会被忽略掉 .log严重级别：critical>error>warning>info>debug

 ==format== 指定log格式

示例1  使用logging 模块打印log

<!--运行log1.py-->

```python
#log1.py
import logging
def main():
# 基本配置
logging.basicConfig(  
     #filename='demo.log',
     level=logging.DEBUG, 
     format='%(levelname)s:%(asctime)s:%(message)s'
    )
logging.critical('This is a critical message') 
logging.error('This is an error message')
logging.warning('This is a waring message')   
logging.info('This is an info message') 
logging.debug('This is a debug message')
if __name__ == '__main__': 
	main()

```

------

##     1.2给库添加日志记录

想给库添加一些日志功能，但又不希望他 影响那些没有使用日志功能的程序，应该创建一个专用的日志对象，并将其初始化。
使用logging 模块的getLogger()函数

 logging.StreamHandler()用来设置标准输出的log格式

logging.FileHandler()用来设置输出到文件中的log 格式

```
FileHandler
```

示例2 使用getLogger()创建log对象

<!--调用 log5.py-->

```python
# mylib.py
# 给库添加日志记录
import logging
import os

logger = logging.getLogger(__name__)
fhandler = logging.FileHandler(os.path.join(r'C:\Users\ying.xue\Desktop\copy', "mylib.log"))

formatter = logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s')
fhandler.setFormatter(formatter)
logger.addHandler(fhandler)
logger.setLevel(logging.DEBUG)   #设置logger对象的log级别过滤器

shandler = logging.StreamHandler()
shandler.setFormatter(formatter)
shandler.setLevel(logging.INFO)
logging.basicConfig(
    level=logging.DEBUG,
    format='%(levelname)s %(name)s %(asctime)s %(message)s'
)
log2 = logging.getLogger('[1234]')
log3 = logging.getLoggerClass()
log4 = log3('[12345]@!#$')

def func():
    logger.info('logger: A Critical Error!')
    log2.critical('log2: Critical Error!')
    log4.critical('log4: A Critical Error!')


if __name__ == '__main__':
    func()
```

**思考** 

使用调用库的脚本不同。因此使用库的环境是不同的，一般来说不应该在库代码中去自行配置日志系统，或者对已有的日志进行配置，而应该采取隔离措施

**作业2** ：创建自己log 类，针对log等级设置不同的颜色，可以制定log的保存路径,可以参考自动化框架中对logging模块的使用和封装（pccolorprt.py）

参考答案：

```python
import logging
import colorlog

log_color_config = {
    'DEBUG': 'white',
    'INFO': 'green',
    'WARNING': 'yellow',
    'ERROR': 'red',
    'CRITICAL': 'bold_red'
}


class Log:
    def __init__(self, logname=None, logpath=None, clevel=logging.DEBUG, Flevel=logging.DEBUG):
        self.logger = logging.getLogger(logname)
        self.logger.setLevel(logging.DEBUG)
        formatter = colorlog.ColoredFormatter(
            fmt='%(log_color)s%(asctime)s-%(name)s-[%(levelname)s]:%(message)s',
            log_colors=log_color_config
        )

        # set cmd log
        sh = logging.StreamHandler()
        sh.setFormatter(formatter)
        sh.setLevel(clevel)
        # set file log
        if logpath is not None:

            fh = logging.FileHandler(logpath)
            fh.setFormatter(formatter)
            fh.setLevel(Flevel)
            self.logger.addHandler(fh)

        self.logger.addHandler(sh)

    def log(self, message='', type='info'):
        if type is None or type == 'info':
            self.info(message)
        elif type == 'debug':
            self.debug(message)
        elif type == 'warning':
            self.warning(message)
        elif type == 'error':
            self.error(message)
        elif type == 'critical':
            self.critical(message)
        else:
            print('please check para')

    def debug(self, message):
        self.logger.debug(message)

    def info(self, message):
        self.logger.info(message)

    def warning(self, message):
        self.logger.warning(message)

    def error(self, message):
        self.logger.error(message)

    def critical(self, message):
        self.logger.critical(message)


if __name__ == '__main__':
    log = Log(logname='devicesnum:ums512u78979832port:1111')
    log.debug('send ok')
    log.info('send ok')
    log.warning('send ok')
    log.error('send ok')
    log.critical('send ok')
    log.log('send ok!','error')
    log.log('send ok!','warning')
    log.log('send ok!','critical')

    log2 = Log(logname='TestFrame')
    log2.debug('send ok')
    log2.info('send ok')
    log2.warning('send ok')
    log2.error('send ok')
    log2.critical('send ok')
    log2.log('send ok!','error')
    log2.log('send ok!','warning')
    log2.log('send ok!','critical')


```



# 2.读写配置文件

配置文件中，值被归组到不同的分组（section)中,在每个分组内对变量设定值，变量（key）是非大小写敏感的
## 2.1读取配置文件的参数
读取以常见的.ini 格式所编写的配置文件用congfigparser 模块ConfigParser()类

常用方法：

defaults()：以字典的方式返回默认的section，即DEFAULT；

sections()：返回section名称的列表，但是不包括DEFAULT；

add_section(section)：添加一个section，字符串类型，且已经存在的section不能再往里添加；

has_section(section)：判断当前配置中是否有此section，DEFAULT不包含在此判断中；

options(section)：返回此section下的option列表；

has_option(section, option)：如果指定的section存在，且包含该option，则返回True，否则返回False；如果传入的section为None或者空字符串，则使用DEFAULT这个section进行查找判断；

==read(filenames, encoding=None)：可以传入单个文件，或者多个文件的列表，如果多个文件中某个文件无法打开，则这个文件会被忽略；==

==read_file(f, source=None)：从一个文件流(不是文件名称)读取配置，source为文件流的名称；==

read_string(string, source='')：从一个字符串读取配置，source为字符串的名称；

read_dict(dictionary, source='')：从一个类字典对象中读取配置信息，source为类字典对象的名称；

==get(section, option, *, raw=False, vars=None[, fallback])：获取section下指定option的值，如果vars被提供了(必须是一个字典)，则按照vars、section、DEFAULT这个顺序进行查找。raw指定为True时，option中value值不会自动进行格式化字符串的转换，直接返回原内容。fallback用于指定当查找的option没有时返回的默认值；==

==getint(section, option, *, raw=False, vars=None[, fallback])：将get的值强转成int类型(raw、vars和fallback参数请参考get方法)；==

==getfloat(section, option, *, raw=Fasle, vars=None[, ballback])：将get的值强转成float类型(raw、vars和fallback参数请参考get方法)；==

==getboolean(section, option, *, raw=False, vars=None[, fallback])：将get的值强转成boolean类型True或False，转换原则为yes/no、on/off、true/false和1/0可以转换为True和False，其他项则会报错(raw、vars和fallback参数请参考get方法)。如果想要自定义转换为True或False的项，可以通过设置parser.BOOLEAN_STATES来定指定，如：parser.BOOLEAN_STATES = {'open': True, 'close': False}，但是这时候意味着没在这个字典中的项就会报错了，包括原来的yes/no等项；==

items((raw=False, vars=None)：返回section的迭代器，包括DEFAULT(raw和vars参数请参考get方法)；

items(section, raw=False, vars=None)：返回指定section下option键值对元组的列表(raw和vars参数请参考get方法)；

==set(section, option, value)：给指定的section设置一个option键值对；==

==write(fileobject, space_around_delimiters=True)：将配置信息写进一个open的文件对象，space_around_delimiters为True时，option的分隔符两边会有空格；==

==remove_option(section, option)：移除指定section下的指定option，成功返回True，否则返回False；==

==remove_section(section)：移除一个section，如果存在且移除成功，则返回True，否则返回False==

示例3 读取和写入ini配置文件

```python
import sys
from configparser import ConfigParser

cfg = ConfigParser()
#读取
cfg.read(r'C:\Users\ying.xue\Desktop\copy\democonfig.ini', encoding="utf-8-sig")
print(cfg.sections())
print(cfg.get('Section1','sn_1'))
print(cfg.get('Section2','port'),type(cfg.get('Section2','port')))
print(cfg.getint('Section2','port'),type(cfg.getint('Section2','port')))
print(cfg.getboolean('Section2','b'),type(cfg.getboolean('Section2','b')))
print(cfg.getboolean('Section2','port'),type(cfg.getboolean('Section2','port')))
print(cfg.getfloat('Section2','f'),type(cfg.getfloat('Section2','f')))
# 修改并写回配置文件
cfg.set('Section2','sn_2','ABCDEF1234')
print(cfg.get('Section2','sn_2'))

cfg.write(sys.stdout)
with open(r'C:\Users\ying.xue\Desktop\copy\democonfig.ini','r+',encoding="utf-8") as fp:
    cfg.write(fp)


print(cfg.get('Section2','sn_2'))
```



##     2.2修改配置文件的参数并写入配置文件

上面修改配置文件会将原来配置文件中的注释覆盖掉，因为在读取原文件时，注释内容是不会iu被读取的，所以写入修改后的配置文件自然没有原来的注释

那么要怎么保留原注释呢？

cf = configparser.ConfigParser(comment_prefixes='/',allow_no_value=True)

通过修改 实例化`ConfigParser()`时 的参数`comment_prefixes`，`allow_no_value=True`  comment_prefixes参数默认值为“#”和“;”，表明配置文件中以“#”或“;”开头的行为注释行，allow_no_value：是否允许key没有对应的value，默认为False，当修改`comment_prefixes='/'`后配置文件中以#；开头的字符串将不被认为是注释，而是普通的key，，以‘/’ 开头的才会被当作注释行，，因此还需要将`allow_no_value 的值改为True`

另外还有一个参数inline_comment_prefixes：，可用来设置行内注释的前缀即一行中这个符号之后的内容被认为是注释；

**ConfigParser 的父类 RawConfigParser ，__init__()中的参数 ：**

```python
class RawConfigParser(MutableMapping):



    def __init__(self, defaults=None, dict_type=_default_dict,
                 allow_no_value=False, *, delimiters=('=', ':'),
                 comment_prefixes=('#', ';'), inline_comment_prefixes=None,
                 strict=True, empty_lines_in_values=True,
                 default_section=DEFAULTSECT,
                 interpolation=_UNSET, converters=_UNSET):

```

defaults：设置配置文件中名为DEFAULT的默认section信息，默认为None，可以传入一个包含option信息的字典；

dict_type：设置读取配置信息时的字典类型，默认为有序字典，即collections.OrderedDict，如果实在要考虑性能等原因，可以使用python默认字典dict；

==allow_no_value：是否允许key没有对应的value，默认为False，如果加载的配置文件中有这种情况，需要手动设置为True；==

delimiters：设置分隔符，默认为“=”和“:”，且一个option中第二个及之后的分隔符会算作value的一部分；

==comment_prefixes：设置注释符，默认为“#”和“;”，即一行的开头(取出空格后)为“#”或者“;”，则这一行算作注释内容，包括value有多行的情况也是如此；==

==inline_comment_prefixes：设置行中的注释前缀，即一行中这个符号之后的内容被认为是注释；==

==strict：默认为True，即读取配置数据时不允许出现重复的section和option；==

empty_lines_in_values：是否允许value中出现空行，默认为True，如果设置为False，则value中的空行将作为这个option的结束标志；

default_section：更改默认的section名称，原本默认的section是DEFAULT(注意更改操作需要在实例化之后，读取数据之前)；

interpolation：设置value的字符串格式化功能，如果不想使用value的字符串格式化功能，可以设置None；

converters：设置将value转换为特定类型的数据，参数值为一个字典，字典的key为转换方法的名称，value为对应的转换函数，提供这个字典后，会自动生成对应的get/set方法，比如提供一个字典{'int': int}就会生成getint转换方法(当然这个方法已经内置有了，这里只是举个例子)。

value字符串格式化：可以使用%(name)s进行字符串的格式化，且name只能是本section和DEFAULT中的option项。

自定义option的key配置方式：如原本是key是自动转化为小写的，现在设置其区分大小写：parser.optionxform = lambda option: option(注意更改操作需要在实例化之后，读取数据之前)。

自定义section自定义配置方式：如原本section是包含了空格以及大小写区分的，现在利用正则表达式设置其去掉首位的空格：parser.SECTCRE = re.compile(r"")(注意更改操作需要在实例化之后，读取数据之前)。

# 3.创建一个秒表计时器

##     3.1创建计时器类

time.time() # 获取当前时间戳

time.perf_counter() # 获取时间戳

time.process_time()  # 获取进程的cpu时间

示例4 创建一个计时器类 记录各项任务所执行的时间，根据用户需要启动，停止，重置，

<!--提问 ：1.property 的作用是什么？2.上下文管理协议是什么？-->



```python
import time
from functools import wraps
from contextlib import contextmanager

func1 = time.time


# func2 = time.perf_counter
# func3 = time.process_time

class Timer:
    def __init__(self, func=time.perf_counter):
        self.elapsed = 0.0
        self._func = func
        self._start = None

    def start(self):
        if self._start is not None:
            raise RuntimeError('Already started')
        self._start = self._func()

    def stop(self):
        if self._start is None:
            raise RuntimeError('Not started')
        end = self._func()
        self.elapsed += end - self._start
        self._start = None

    def reset(self):
        self.elapsed = 0.0

    @property
    def running(self):
        return self._start is not None

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.stop()


def timethis(func):
    # @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        r = func(*args, **kwargs)
        end = time.perf_counter()
        print('{}.{} cost {} s'.format(func.__module__, func.__name__, end - start))
        return r

    return wrapper


@timethis
def test():
    """
    doc for test
    :return:
    """
    a = []
    for i in range(5):
        a.append(i)
        time.sleep(0.1)


@contextmanager
def timeblock():

    start = time.perf_counter()

    yield

    end = time.perf_counter()
    print('cost :', end - start)


if __name__ == '__main__':
    with timeblock():
        test()
        print(test.__name__)
        print(test.__doc__)
        t = Timer(func1)
        t.start()
        time.sleep(1)
        t.stop()
        print(t.elapsed)
        with t:
            time.sleep(1)
        print(t.elapsed)
        t.reset()
        with t:
            time.sleep(1)
        print(t.elapsed)

```

##     3.2.为函数计时

为某个函数计时，可以使用装饰器

 <!--提问 wraps(func)的作用是什么-->

示例5 给函数添加计时功能

```python
def timethis(func):
    # @wraps(func)     
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        r = func(*args, **kwargs)
        end = time.perf_counter()
        print('{}.{} cost {} s'.format(func.__module__, func.__name__, end - start))
        return r

    return wrapper


@timethis
def test():
    """
    doc for test
    :return:
    """
    a = []
    for i in range(5):
        a.append(i)
        time.sleep(0.1)
```

使用装饰器
@timethis
def test():
    …
和下面的语句效果一样：
def test():
    …
test = timethis(test)

**说明**
timethis(test) 先将test作为参数传给timethis, 返回一个函数名为wrapper的函数对象 ,并把这个函数对象赋值给test,调用test()相当于调用 wrapper,wrapper 内部对原函数进行了包装（增加计时功能）并且会执行原函数，如果原函数有返回值，wrapper 会返回原函数的结果

***



##     3.3.为代码块计时

可以==借助contextlib模块中的contextmanager装饰器==定义一个上下文管理器，将需要计时的代码块放在with代码块内部

contextmanager的作用是 让生成器函数支持上下文管理协议

示例6 给代码块计时

```python
@contextmanager
def timeblock():
    start = time.perf_counter()
    try:
        yield    
    finally:    
        end = time.perf_counter()
        print(print('cost :', end - start))

```

contexmanager 的源码：

```python
def contextmanager(func):
    """@contextmanager decorator.

    Typical usage:

        @contextmanager
        def some_generator(<arguments>):
            <setup>
            try:
                yield <value>
            finally:
                <cleanup>

    This makes this:

        with some_generator(<arguments>) as <variable>:
            <body>

    equivalent to this:

        <setup>
        try:
            <variable> = <value>
            <body>
        finally:
            <cleanup>
    """
    @wraps(func)
    def helper(*args, **kwds):
        return _GeneratorContextManager(func, args, kwds)
    return helper
```



![image-20211212075602658](C:\Users\ying.xue\AppData\Roaming\Typora\typora-user-images\image-20211212075602658.png)



![image-20211212075611326](C:\Users\ying.xue\AppData\Roaming\Typora\typora-user-images\image-20211212075611326.png)

![image-20211212075627100](C:\Users\ying.xue\AppData\Roaming\Typora\typora-user-images\image-20211212075627100.png)

# 4.处理外部命令

##  4.1简单命令

需求 ：想执行一个外部命令比如：adb devices 并获取输出

有以下几种办法

以下3方法只会返回执行的状态码，当执行成功时返回0，只会打印而 不会返回执行结果
os.system()
subprocess.call()
subprocess,check_call()

<u>subprocess.check_output()可以返回执行结果的字节串</u>

```python
import os
import subprocess

a = subprocess.call ('adb devices')
print('a',a)

b = os.system('adb devices')
print('b',b)

c = subprocess.check_call('adb devices')   # 区别在于如果返回值0 会触发CallProcessError
print('c',c)
out_bytes = subprocess.check_output('adb devices') # 会返回子进程的执行后的结果
print(out_bytes.decode())
c
# 捕获异常，
try:
    out_bytes = subprocess.check_output('adb device')
    print(out_bytes.decode())
except subprocess.CalledProcessError as e:

    out_bytes = e.output
    print(out_bytes)
    code = e.returncode
    print(code)
    # raise
#
# 希望获取到标准错误，可以使用参数stderr
out_bytes = subprocess.check_output('adb device',stderr=subprocess.STDOUT)#stderr = subprocess.STDOUT
err= out_bytes.stderr
print(err.read())
# 如果需要执行一个带有超时机制的命令
try:
    out_bytes = subprocess.check_output('ping www.baidu.com',timeout=5)
    print(out_bytes)
except subprocess.TimeoutExpired as e:
    print('timeout')


```

## 4.2 与子进程交互

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

预备知识　管道是什么？

说明：**管 道（Pipe）实际是用于进程间通信的一段共享内存**，创建管道的进程称为**管道服务器**，连接到一个管道的进程为**管道客户机**。一个进程在向管道写入数据后，另 一进程就可以从管道的另一端将其读取出来

- 先简单介绍一下**重定向**：

*stdin是标准输入，stdout是标准输出，stderr是标准错误输出。大多数的命令行程序从stdin输入，输出到stdout或 stderr，有时我们需要重定向stdout,stderr,stdin。比如：将输出写入文件，又或者我们要将命令行程序输出结果显示到 Windows对话框中。*

*在Windows编程中，重定向需要用到管道(Pipe)的概念。管道是一种用于在进程间共享数据的机制。一个管道类似于一个管子的两端，一端是写入的，一端是读出的。由一个进程从写入端写入、另一个进程从读出端读出，从而实现通信，就向一个“管道”一样。*

*重定向的原理是：*

*首先声明两个概念：主程序(重定向的操纵者)、子进程(被重定向的子进程)*

*如果要重定位stdout的话，先生成一个管道， 管道的写入端交给子进程去写，主程序从管道的读出端读数据，然后可以把数据写成文件、显示等等。重定向stderr和stdout是相同的。*

*同理，要重定向stdin的话，生成一个管道， 管道的写入端由主程序写，子进程从管道的读出端读数据*。

其中需要用到几个Windows API : CreatePipe, DuplicateHandle, CreateProcess, ReadFile, WriteFile 等

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

subprocess.Popen()类

调用方法举例：

```python
sub_process = subprocess.Popen(command, stdin = subprocess.PIPE,stdout = subprocess.PIPE,stderr = subprocess.PIPE, shell = True)
```

**参数说明：**

args 可以是一个字符串，可以是一个包含程序参数的列表。要执行的程序一般就是这个列表的第一项，或者是字符串本身。
stdin、stdout、stderr分别表示子程序的标准输入、标准输出和标准错误。可选的值有PIPE或者一个有效的文件描述符或者一个文件对象，还有None。如果是PIPE，则表示需要创建一个新的管道，如果是None，不会做任何重定向工作，子进程的文件描述符会继承父进程的。另外，stderr的值还可以是STDOUT，表示子进程的标准错误也输出到标准输出。
bufsize 0表示不缓冲，1表示行缓冲，其他正数表示近似的缓冲区字节数，负数表示使用系统默认值。默认是0。
executable指定要执行的程序。它很少会被用到：一般程序可以由args 参数指定。如果shell=True ，可以用于指定用哪个shell来执行（比如bash、csh、zsh等）。*nix下，默认是 /bin/sh ，windows下，就是环境变量 COMSPEC 的值。windows下，只有当你要执行的命令确实是shell内建命令（比如dir ，copy 等）时，你才需要指定shell=True ，而当你要执行一个基于命令行的批处理脚本的时候，不需要指定此项。



参考：<https://blog.csdn.net/weixin_30411239/article/details/95735472>



==Popen对象的方法==

p.poll()检查子进程是否已结束，设置并返回returncode属性
p.wait()等待子进程结束，设置并返回returncode属性
说明：如果子进程输出了大量数据到stdout或者stderr的管道，并达到了系统pipe的缓存大小的话，子进程会等待父进程读取管道，而父进程此时正wait着的话，将会产生死锁。建议使用p.communicate() 来避免这种情况的发生。
p.communicate(input=None)和子进程交互：发送数据到stdin，并从stdout和stderr读数据，直到收到EOF()。等待子进程结束。可选的input如有的话，要为字符串类型。此函数返回一个元组： (stdoutdata , stderrdata ) 。
p.kill()杀死子进程
p.terminate()停止子进程

==Popen对象的属性==

p.stdin如果stdin 参数是PIPE，此属性就是一个io对象，否则为None 
p.stdout如果stdout参数是PIPE，此属性就是一个io对象，否则为Nonevvvv                                                                                         p.stderr如果stderr 参数是PIPE，此属性就是一个io对象，否则为None 
p.pid 子进程的进程号。注意，如果shell 参数为True，这属性指的是子shell的进程号

==重点说明 给stdin ,stdout stderr 三个参数 赋值为subprocess.PIPE  的用法==

参考：https://blog.csdn.net/weixin_39885690/article/details/111750934

  <!--备注 ：解析Popen()源码-->

step1 处理传入的参数stdin stdout stderr

```python
 # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread
        # c2pread    <--stdout---  c2pwrite
        # errread    <--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    　
    
    (p2cread, p2cwrite,
     c2pread, c2pwrite,
     errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
    
```

当传入的参数都为 PIPE (在subprocess.py 中的值是-1) 调用  _winapi创建管道CreatePipe（） 返回一个元组 

p2cread, p2cwrite用于标识　stdｉｎ　管道的两端读和写：父进程往该管道里面写入数据，子进程从管道里面读取数据c2pread, c2pwrite用于标识　ｓｔｄｏｕｔ　管道的两端读和写：子进程往管道里写入数据，父进程从管道里读取数据errread, errwrite用于标识　ｓｔｄｅｒｒ　管道的两端读和写：　子进程往管道里写入错误信息，父进程从管道里读取错误信息　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　

```python

 Windows methods
#_get_handles()中的处理
 　　　 # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread　　　　
        # c2pread    <--stdout---  c2pwrite
        # errread    <--stderr---  errwrite

elif stdin == PIPE:
    p2cread, p2cwrite = _winapi.CreatePipe(None, 0)
    #CreatePipe时会获取两个句柄，一个是读句柄，一个是写句柄（这里的读句柄表示要从哪里读取数据，写句柄表示要把数据写到哪里）也就是管道的文件描述符
    p2cread, p2cwrite = Handle(p2cread), Handle(p2cwrite)
    
elif stdout == PIPE:
     c2pread, c2pwrite = _winapi.CreatePipe(None, 0)
     c2pread, c2pwrite = Handle(c2pread), Handle(c2pwrite)  
    
 elif stderr == PIPE:
     errread, errwrite = _winapi.CreatePipe(None, 0)
     errread, errwrite = Handle(errread), Handle(errwrite)
 elif stderr == STDOUT:
     errwrite = c2pwrite
```

step3　　ｗｒａｐ　描述符

为什么要先ｗｒａｐ　

＂We wrap OS handles *before* launching the child, otherwise a　quickly terminating child could make our fds unwrappable＂

*我们在启动子进程之前包装操作系统句柄，否则快速终止子进程可能会使我们的 fds 不可包装*（<u>这句话不太理解</u>）

```python
if _mswindows:
    if p2cwrite != -1:
        p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
    if c2pread != -1:
        c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
    if errread != -1:
        errread = msvcrt.open_osfhandle(errread.Detach(), 0)
```

step4 将管道的文件描述符打开为ｓｔｒｅａm　

```python
try:
    if p2cwrite != -1:
        self.stdin = io.open(p2cwrite, 'wb', bufsize)  #　 Open file and return a stream
　　　　 """
    　 Open file and return a stream.  Raise OSError upon failure.
    
    file is either a text or byte string giving the name (and the path
    if the file isn't in the current working directory) of the file to
    be opened or an integer file descriptor of the file to be
    wrapped. (If a file descriptor is given, it is closed when the
    returned I/O object is closed, unless closefd is set to False.)
        """
        if self.text_mode:
            self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                    line_buffering=line_buffering,
                    encoding=encoding, errors=errors)
    if c2pread != -1:
        self.stdout = io.open(c2pread, 'rb', bufsize)
        if self.text_mode:
            self.stdout = io.TextIOWrapper(self.stdout,
                    encoding=encoding, errors=errors)
    if errread != -1:
        self.stderr = io.open(errread, 'rb', bufsize)
        if self.text_mode:
            self.stderr = io.TextIOWrapper(self.stderr,
                    encoding=encoding, errors=errors)
            
          
　　 #　ｓｔｅｐ　５　子进程内部将自己的输出绑定到管道上
    self._execute_child(args, executable, preexec_fn, close_fds,
                        pass_fds, cwd, env,
                        startupinfo, creationflags, shell,
                        p2cread, p2cwrite,
                        c2pread, c2pwrite,
                        errread, errwrite,
                        restore_signals,
                        gid, gids, uid, umask,
                        start_new_session)
except:
    ...

    
```



下面总结下,创建Popen对象时，子进程是如何可以和父进程通信

我们传入subprocess.PIPE。

内部通过创建1-3个管道生成的子进程复制了这些管道的文件描述符，

子进程内部将自己的输出绑定到这写管道上

父进程通过io.open将管道的文件描述符打开为　openfile　对象（流）

并赋值给self.stdin  self.stdout stderr因为是openfile对象，我们就可以直接通过read、readline、readlines等方法获取回显的字符串了

<!--提问　为什么父进程和子进程可以通信-->

<!--答案　就是因为管道有两端，读端和写端。创建管道，然后从父进程fork出子进程，父进程和子进程拥有共同的读写文件描述符，可以实现子进程写文件，父进程读文件的操作，或者父进程写，子进程读-->



 ==**思考与讨论 如果如何避免死锁**==

read() readline() readlines() 是阻塞式读取结果的，也就是说得等到子程序执行完毕后才能从管道里取出数据，如果子程序无法正常结束呢，比如ping 百度时 不小心给-n 传了一个巨大的数值 。子程序往管道里不停的写入数据，直到把管道写满，导致死锁。

由于openfile对象的read、readline、readlines方法都是阻塞的，那么我们可以这样。新建立一个线程去读取，并把读出来的内容塞入一个列表，我们主进程都去读取这个列表的最后一项　线程中读取后写入列表的延迟 需要大于主进程读取列表最后一项的延迟，以免判断内容还没被主进程读取已经进入下一列读取子进程回显函数         

示例 读取ping 百度的结果　如何非阻塞式读取

```python
import subprocess

p = subprocess.Popen('ping -n 10 www.baidu.com', stdout=subprocess.PIPE, shell=True)
# for line in p.stdout:
# 	print(line.decode('gbk'))        # 和communicate()类似

print('=====p====:',p)
print('====p.stdout===:',p.stdout)
print(p.stdout.readlines())

```

